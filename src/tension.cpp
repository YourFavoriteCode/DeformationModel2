// This is an open source non-commercial project. Dear PVS-Studio, please check it.

// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com

#include "stdafx.h"

#include "Tension.h"
#include "Eigen/Eigen"

namespace model
{
	Tensor TensionStrainCalc(const Tensor4 P, const Tensor D_in, const double tens_comp)
	{
		/*
		Пересчитывает тензор деформации скорости исходя из решения СЛАУ
		*/
		Eigen::MatrixXd A(5, 5);
		Eigen::VectorXd B(5), X(5);

		/*A(0, 0) = P.C[1][1][0][1] + P.C[1][1][1][0];
		A(0, 1) = P.C[1][1][0][2] + P.C[1][1][2][0];
		A(0, 2) = P.C[1][1][1][2] + P.C[1][1][2][1];
		A(0, 3) = P.C[1][1][1][1];
		A(0, 4) = P.C[1][1][2][2];

		A(1, 0) = P.C[2][2][0][1] + P.C[2][2][1][0];
		A(1, 1) = P.C[2][2][0][2] + P.C[2][2][2][0];
		A(1, 2) = P.C[2][2][1][2] + P.C[2][2][2][1];
		A(1, 3) = P.C[2][2][1][1];
		A(1, 4) = P.C[2][2][2][2];

		A(2, 0) = P.C[0][1][0][1] + P.C[0][1][1][0];
		A(2, 1) = P.C[0][1][0][2] + P.C[0][1][2][0];
		A(2, 2) = P.C[0][1][1][2] + P.C[0][1][2][1];
		A(2, 3) = P.C[0][1][1][1];
		A(2, 4) = P.C[0][1][2][2];

		A(3, 0) = P.C[0][2][0][1] + P.C[0][2][1][0];
		A(3, 1) = P.C[0][2][0][2] + P.C[0][2][2][0];
		A(3, 2) = P.C[0][2][1][2] + P.C[0][2][2][1];
		A(3, 3) = P.C[0][2][1][1];
		A(3, 4) = P.C[0][2][2][2];

		A(4, 0) = P.C[1][2][0][1] + P.C[1][2][1][0];
		A(4, 1) = P.C[1][2][0][2] + P.C[1][2][2][0];
		A(4, 2) = P.C[1][2][1][2] + P.C[1][2][2][1];
		A(4, 3) = P.C[1][2][1][1];
		A(4, 4) = P.C[1][2][2][2];*/
		
		for (int i = 0; i < 5; i++)
		{
			int k, l;
			switch (i)
			{
			case 0:
			{
				k = 1;
				l = 1;
				break;
			}
			case 1:
			{
				k = 2;
				l = 2;
				break;
			}
			case 2:
			{
				k = 0;
				l = 1;
				break;
			}
			case 3:
			{
				k = 0;
				l = 2;
				break;
			}
			case 4:
			{
				k = 1;
				l = 2;
				break;
			}
			}
			B(i) = P.C[k][l][0][0] * (-tens_comp + D_in.c[0][0]);
			for (int j = 0; j < 5; j++)
			{
				int y, z;
				switch (j)
				{
				case 0:
				{
					y = 0;
					z = 1;
					break;
				}
				case 1:
				{
					y = 0;
					z = 2;
					break;
				}
				case 2:
				{
					y = 1;
					z = 2;
					break;
				}
				case 3:
				{
					y = 1;
					z = 1;
					break;
				}
				case 4:
				{
					y = 2;
					z = 2;
					break;
				}
				}
				if (y != z)
				{
					A(i, j) = P.C[k][l][y][z] + P.C[k][l][z][y];
					B(i) += (P.C[k][l][y][z] + P.C[k][l][z][y])*D_in.c[y][z];
				}
				else
				{
					A(i, j) = P.C[k][l][y][z];
					B(i) += P.C[k][l][y][z]*D_in.c[y][z];
				}
			}
		}

		/*B(0) = P.C[1][1][0][0] * (-tens_comp + D_in.C[0][0]) + (P.C[1][1][0][1] + P.C[1][1][1][0])*D_in.C[0][1] +
			(P.C[1][1][0][2] + P.C[1][1][2][0])*D_in.C[0][2] + (P.C[1][1][1][2] + P.C[1][1][2][1])*D_in.C[1][2] +
			P.C[1][1][1][1] * D_in.C[1][1] + P.C[1][1][2][2] * D_in.C[2][2];

		B(1) = P.C[2][2][0][0] * (-tens_comp + D_in.C[0][0]) + (P.C[2][2][0][1] + P.C[2][2][1][0])*D_in.C[0][1] +
			(P.C[2][2][0][2] + P.C[2][2][2][0])*D_in.C[0][2] + (P.C[2][2][1][2] + P.C[2][2][2][1])*D_in.C[1][2] +
			P.C[2][2][1][1] * D_in.C[1][1] + P.C[2][2][2][2] * D_in.C[2][2];

		B(2) = P.C[0][1][0][0] * (-tens_comp + D_in.C[0][0]) + (P.C[0][1][0][1] + P.C[0][1][1][0])*D_in.C[0][1] +
			(P.C[0][1][0][2] + P.C[0][1][2][0])*D_in.C[0][2] + (P.C[0][1][1][2] + P.C[0][1][2][1])*D_in.C[1][2] +
			P.C[0][1][1][1] * D_in.C[1][1] + P.C[0][1][2][2] * D_in.C[2][2];

		B(3) = P.C[0][2][0][0] * (-tens_comp + D_in.C[0][0]) + (P.C[0][2][0][1] + P.C[0][2][1][0])*D_in.C[0][1] +
			(P.C[0][2][0][2] + P.C[0][2][2][0])*D_in.C[0][2] + (P.C[0][2][1][2] + P.C[0][2][2][1])*D_in.C[1][2] +
			P.C[0][2][1][1] * D_in.C[1][1] + P.C[0][2][2][2] * D_in.C[2][2];

		B(4) = P.C[1][2][0][0] * (-tens_comp + D_in.C[0][0]) + (P.C[1][2][0][1] + P.C[1][2][1][0])*D_in.C[0][1] +
			(P.C[1][2][0][2] + P.C[1][2][2][0])*D_in.C[0][2] + (P.C[1][2][1][2] + P.C[1][2][2][1])*D_in.C[1][2] +
			P.C[1][2][1][1] * D_in.C[1][1] + P.C[1][2][2][2] * D_in.C[2][2];*/

		X = A.fullPivHouseholderQr().solve(B);

		Tensor res;
		res.c[0][1] = res.c[1][0] = X(0);
		res.c[0][2] = res.c[2][0] = X(1);
		res.c[1][2] = res.c[2][1] = X(2);
		res.c[1][1] = X(3);
		res.c[2][2] = X(4);
		res.c[0][0] = tens_comp;
		return res;
	}

	Tensor TensionStressCalc(Tensor4 &P, Tensor &D_in, Tensor &D)
	{
		Tensor res;
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{
					for (int l = 0; l < 3; l++)
					{
						res.c[i][j] += P.C[i][j][k][l] * (D.c[l][k] - D_in.c[l][k]);
					}
				}
			}
		}
		return res;
	}
	Tensor UnloadingStrainCalc(Tensor4 &P, Tensor &D_in, Tensor &Sgm, double lam)
	{
		Eigen::MatrixXd Ar(6, 6);
		Eigen::VectorXd Br(6), Xr(6);

		/*Ar(0, 0) = P.C[1][1][0][1] + P.C[1][1][1][0];
		Ar(0, 1) = P.C[1][1][0][2] + P.C[1][1][2][0];
		Ar(0, 2) = P.C[1][1][1][2] + P.C[1][1][2][1];
		Ar(0, 3) = P.C[1][1][1][1];
		Ar(0, 4) = P.C[1][1][2][2];
		Ar(0, 5) = P.C[1][1][0][0];

		Ar(1, 0) = P.C[2][2][0][1] + P.C[2][2][1][0];
		Ar(1, 1) = P.C[2][2][0][2] + P.C[2][2][2][0];
		Ar(1, 2) = P.C[2][2][1][2] + P.C[2][2][2][1];
		Ar(1, 3) = P.C[2][2][1][1];
		Ar(1, 4) = P.C[2][2][2][2];
		Ar(1, 5) = P.C[2][2][0][0];

		Ar(2, 0) = P.C[0][1][0][1] + P.C[0][1][1][0];
		Ar(2, 1) = P.C[0][1][0][2] + P.C[0][1][2][0];
		Ar(2, 2) = P.C[0][1][1][2] + P.C[0][1][2][1];
		Ar(2, 3) = P.C[0][1][1][1];
		Ar(2, 4) = P.C[0][1][2][2];
		Ar(2, 5) = P.C[0][1][0][0];

		Ar(3, 0) = P.C[0][2][0][1] + P.C[0][2][1][0];
		Ar(3, 1) = P.C[0][2][0][2] + P.C[0][2][2][0];
		Ar(3, 2) = P.C[0][2][1][2] + P.C[0][2][2][1];
		Ar(3, 3) = P.C[0][2][1][1];
		Ar(3, 4) = P.C[0][2][2][2];
		Ar(3, 5) = P.C[0][2][0][0];

		Ar(4, 0) = P.C[1][2][0][1] + P.C[1][2][1][0];
		Ar(4, 1) = P.C[1][2][0][2] + P.C[1][2][2][0];
		Ar(4, 2) = P.C[1][2][1][2] + P.C[1][2][2][1];
		Ar(4, 3) = P.C[1][2][1][1];
		Ar(4, 4) = P.C[1][2][2][2];
		Ar(4, 5) = P.C[1][2][0][0];

		Ar(5, 0) = P.C[0][0][0][1] + P.C[0][0][1][0];
		Ar(5, 1) = P.C[0][0][0][2] + P.C[0][0][2][0];
		Ar(5, 2) = P.C[0][0][1][2] + P.C[0][0][2][1];
		Ar(5, 3) = P.C[0][0][1][1];
		Ar(5, 4) = P.C[0][0][2][2];
		Ar(5, 5) = P.C[0][0][0][0];*/

		/*	Br(0) = -lam*Sgm.C[1][1] + (P.C[1][1][0][0] * D_in.C[0][0] + (P.C[1][1][0][1] + P.C[1][1][1][0])*D_in.C[0][1] +
		(P.C[1][1][0][2] + P.C[1][1][2][0])*D_in.C[0][2] + (P.C[1][1][1][2] + P.C[1][1][2][1])*D_in.C[1][2] +
		P.C[1][1][1][1] * D_in.C[1][1] + P.C[1][1][2][2] * D_in.C[2][2]);
		Br(1) = -lam*Sgm.C[2][2] + (P.C[2][2][0][0] * D_in.C[0][0] + (P.C[2][2][0][1] + P.C[2][2][1][0])*D_in.C[0][1] +
		(P.C[2][2][0][2] + P.C[2][2][2][0])*D_in.C[0][2] + (P.C[2][2][1][2] + P.C[2][2][2][1])*D_in.C[1][2] +
		P.C[2][2][1][1] * D_in.C[1][1] + P.C[2][2][2][2] * D_in.C[2][2]);
		Br(2) = -lam*Sgm.C[0][1] + (P.C[0][1][0][0] * D_in.C[0][0] + (P.C[0][1][0][1] + P.C[0][1][1][0])*D_in.C[0][1] +
		(P.C[0][1][0][2] + P.C[0][1][2][0])*D_in.C[0][2] + (P.C[0][1][1][2] + P.C[0][1][2][1])*D_in.C[1][2] +
		P.C[0][1][1][1] * D_in.C[1][1] + P.C[0][1][2][2] * D_in.C[2][2]);
		Br(3) = -lam*Sgm.C[0][2] + (P.C[0][2][0][0] * D_in.C[0][0] + (P.C[0][2][0][1] + P.C[0][2][1][0])*D_in.C[0][1] +
		(P.C[0][2][0][2] + P.C[0][2][2][0])*D_in.C[0][2] + (P.C[0][2][1][2] + P.C[0][2][2][1])*D_in.C[1][2] +
		P.C[0][2][1][1] * D_in.C[1][1] + P.C[0][2][2][2] * D_in.C[2][2]);
		Br(4) = -lam*Sgm.C[1][2] + (P.C[1][2][0][0] * D_in.C[0][0] + (P.C[1][2][0][1] + P.C[1][2][1][0])*D_in.C[0][1] +
		(P.C[1][2][0][2] + P.C[1][2][2][0])*D_in.C[0][2] + (P.C[1][2][1][2] + P.C[1][2][2][1])*D_in.C[1][2] +
		P.C[1][2][1][1] * D_in.C[1][1] + P.C[1][2][2][2] * D_in.C[2][2]);
		Br(5) = -lam*Sgm.C[0][0] + (P.C[0][0][0][0] * D_in.C[0][0] + (P.C[0][0][0][1] + P.C[0][0][1][0])*D_in.C[0][1] +
		(P.C[0][0][0][2] + P.C[0][0][2][0])*D_in.C[0][2] + (P.C[0][0][1][2] + P.C[0][0][2][1])*D_in.C[1][2] +
		P.C[0][0][1][1] * D_in.C[1][1] + P.C[0][0][2][2] * D_in.C[2][2]);*/
		for (int i = 0; i < 6; i++)
		{
			int k, l;
			switch (i)
			{
			case 0:
			{
				k = 1;
				l = 1;
				break;
			}
			case 1:
			{
				k = 2;
				l = 2;
				break;
			}
			case 2:
			{
				k = 0;
				l = 1;
				break;
			}
			case 3:
			{
				k = 0;
				l = 2;
				break;
			}
			case 4:
			{
				k = 1;
				l = 2;
				break;
			}
			case 5:
			{
				k = 0;
				l = 0;
				break;
			}
			}
			Br(i) = -lam*Sgm.c[k][l];
			for (int j = 0; j < 6; j++)
			{
				int y, z;
				switch (j)
				{
				case 0:
				{
					y = 0;
					z = 1;
					break;
				}
				case 1:
				{
					y = 0;
					z = 2;
					break;
				}
				case 2:
				{
					y = 1;
					z = 2;
					break;
				}
				case 3:
				{
					y = 1;
					z = 1;
					break;
				}
				case 4:
				{
					y = 2;
					z = 2;
					break;
				}
				case 5:
				{
					y = 0;
					z = 0;
					break;
				}
				}
				if (y != z)
				{
					Ar(i, j) = P.C[k][l][y][z] + P.C[k][l][z][y];
					Br(i) += (P.C[k][l][y][z] + P.C[k][l][z][y])*D_in.c[y][z];
				}
				else
				{
					Ar(i, j) = P.C[k][l][y][z];
					Br(i) += P.C[k][l][y][z] * D_in.c[y][z];
				}
			}
		}
	

		Xr = Ar.fullPivHouseholderQr().solve(Br);
		Tensor res;
		res.c[0][1] = res.c[1][0] = Xr(0);
		res.c[0][2] = res.c[2][0] = Xr(1);
		res.c[1][2] = res.c[2][1] = Xr(2);
		res.c[1][1] = Xr(3);
		res.c[2][2] = Xr(4);
		res.c[0][0] = Xr(5);
		return res;
	}
}